/**
 *   .       .     ..
 *  _| _  _.*|_  _ ||
 * (_](/,(_.|[_)(/,||
 *
 * DeciBell : A Java Tool for creating and managing relational databases.
 *  DeciBell is a Object - Relation database mapper for java applications providing
 * an easy-to-use interface making it easy for the developer to build a relational
 * database and moreover perform database operations easily!
 *  This project was developed at the Automatic Control Lab in the Chemical Engineering
 * School of the National Technical University of Athens. Please read README for more
 * information.
 *
 * Copyright (C) 2009-2010 Charalampos Chomenides & Pantelis Sopasakis
 *                         kinkyDesign ~ OpenSource Development

 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Contact:
 * hampos Att yahoo d0t c0m
 * chvng att mail D0t ntua dd0T gr
 * Address: Iroon Politechniou St. 9, Zografou, Athens Greece
 * tel. +30 210 7723236
 */
package org.kinkydesign.decibell.db.derby;

import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedHashSet;
import java.util.Set;
import org.kinkydesign.decibell.collections.LogicalOperator;
import org.kinkydesign.decibell.collections.Qualifier;
import org.kinkydesign.decibell.collections.SQLType;
import org.kinkydesign.decibell.db.Table;
import org.kinkydesign.decibell.db.TableColumn;

import static org.kinkydesign.decibell.db.derby.util.DerbyKeyWord.*;

/**
 *
 * A Table in the database is characterized by its columns. This class offers a
 * flexible tool for manipulating database tables (creating and deleting them).
 *
 * @author Pantelis Sopasakis
 * @author Charalampos Chomenides
 */
public final class DerbyTable extends Table {

    /**
     * Construct a new Table object.
     */
    public DerbyTable() {
        super();
    }

    /**
     * Constructs the Derby SQL command that creates the required table according
     * to the TableColumns it includes.
     * @return SQL Table Creation String for Derby
     */
    public String getCreationSQL() {
        String SQL = CREATE_TABLE + SPACE + getTableName() + NEWLINE + LEFT_PAR + SPACE;
        Iterator<TableColumn> it = super.getTableColumns().iterator();
        while (it.hasNext()) {
            TableColumn column = it.next();
            SQL = SQL + column.getColumnName() + SPACE + column.getColumnType().toString() + SPACE;

            if (column.isUnique()) {
                SQL += UNIQUE + SPACE;
            }
            if (column.isNotNull() || column.isPrimaryKey()) {
                SQL += NOT_NULL + SPACE;
            }
            if (column.isAutoGenerated()) {
                SQL += GAAId + SPACE;
            }

            if (column.hasDefault()) {
                SQL += DEFAULT + SPACE + column.getDefaultValue() + SPACE;
            }

            if (column.isConstrained()) {
                SQL += getConstraint(column) + SPACE;
            }
            SQL += COMMA + NEWLINE;
        }
//        if (!getForeignKeyColumns().isEmpty()) {
//            Set<TableColumn> foreignColumns = new LinkedHashSet<TableColumn>(getForeignKeyColumns());
//            while (!foreignColumns.isEmpty()) {
//                it = foreignColumns.iterator();
//                TableColumn fk = it.next();
//                it.remove();
//                String foreignKey = Fk + SPACE + LEFT_PAR + fk.getColumnName();
//                String references = REFERENCES + SPACE + fk.getReferenceTableName() + LEFT_PAR + fk.getReferenceColumnName() + SPACE;
//                String options = ON + SPACE + DELETE + SPACE + fk.getOnDelete() + SPACE + ON + SPACE + UPDATE + SPACE + fk.getOnUpdate();
//                while (it.hasNext()) {
//                    TableColumn c = it.next();
//                    if (/*fk.getReferenceTable().equals(c.getReferenceTable()) &&*/fk.getField().equals(c.getField())) {
//                        foreignKey += COMMA + c.getColumnName();
//                        references += COMMA + c.getReferenceColumnName();
//                        it.remove();
//                    }
//                }
//                foreignKey += RIGHT_PAR + SPACE;
//                references += RIGHT_PAR + SPACE;
//                SQL += foreignKey + references + options + COMMA + NEWLINE;
//            }
//        }
        Set<Set<TableColumn>> foreignGroups = getForeignColumnsByGroup();
        if (!foreignGroups.isEmpty()) {
            for (Set<TableColumn> group : foreignGroups) {
                String foreignKey = "";
                String references = "";
                String options = "";
                it = group.iterator();
                while (it.hasNext()) {
                    TableColumn col = it.next();
                    if (foreignKey.isEmpty()) {
                        foreignKey = Fk + SPACE + LEFT_PAR;
                    }
                    if (references.isEmpty()) {
                        references = REFERENCES + SPACE + col.getReferenceTableName() + LEFT_PAR;
                    }
                    if (options.isEmpty()) {
                        options = ON + SPACE + DELETE + SPACE + col.getOnDelete() + SPACE + ON + SPACE + UPDATE + SPACE + col.getOnUpdate();
                    }
                    foreignKey += col.getColumnName();
                    references += col.getReferenceColumnName();
                    if (it.hasNext()) {
                        foreignKey += COMMA;
                        references += COMMA;
                    }
                }
                foreignKey += RIGHT_PAR + SPACE;
                references += RIGHT_PAR + SPACE;
                SQL += foreignKey + references + options + COMMA + NEWLINE;
                foreignKey = "";
                references = "";
                options = "";
            }
        }
        SQL += Pk + SPACE + LEFT_PAR;
        it = getPrimaryKeyColumns().iterator();
        while (it.hasNext()) {
            SQL += it.next().getColumnName();
            if (it.hasNext()) {
                SQL += COMMA;
            }
        }
        SQL += RIGHT_PAR;
        SQL = SQL + NEWLINE + RIGHT_PAR;
        System.out.println(SQL);
        return SQL;
    }

    /**
     * Constructs the Deletion SQL command required to delete this table.
     * @return SQL Table Deletion String for Derby
     */
    public String getDeletionSQL() {
        String SQL = DROP_TABLE + SPACE + getTableName();
        return SQL;
    }

    /**
     * Private Method that constructs the SQL String regarding a column's
     * Constraints.
     * @param col the specified TableColumn
     * @return SQL String describing Constraints
     */
    private String getConstraint(TableColumn col) {
        String constraint = "";
        String lowStr = "";
        String highStr = "";
        String domainStr = "";
        Set<String> tempSet = new HashSet<String>();
        if (col.isConstrained()) {
            if (col.hasLow()) {
                lowStr += col.getColumnName() + Qualifier.GREATER_EQUAL + col.getLow();
                tempSet.add(lowStr);
            }
            if (col.hasHigh()) {
                highStr += col.getColumnName() + Qualifier.LESS_EQUAL + col.getHigh();
                tempSet.add(highStr);
            }
            if (col.hasDomain()) {
                for (int i = 0; i < col.getDomain().length; i++) {
                    if (!col.getDomain()[i].isEmpty()) {
                        if (domainStr.isEmpty()) {
                            domainStr = col.getColumnName() + SPACE + IN + SPACE + LEFT_PAR;
                        } else {
                            domainStr += COMMA + SPACE;
                        }
                        if (col.getColumnType().equals(SQLType.VARCHAR) || col.getColumnType().equals(SQLType.LONG_VARCHAR)) {
                            domainStr += SINGLE_QUOTE + col.getDomain()[i] + SINGLE_QUOTE;
                        } else {
                            domainStr += col.getDomain()[i];
                        }
                        if (i == col.getDomain().length - 1) {
                            domainStr += SPACE + RIGHT_PAR;
                        }
                    }
                }
                tempSet.add(domainStr);
            }
            Iterator<String> it = tempSet.iterator();
            while (it.hasNext()) {
                if (constraint.isEmpty()) {
                    constraint = SPACE + CONSTRAINT + SPACE + col.getColumnName() + UNDERSCORE + CONSTRAINT + SPACE + CHECK + SPACE + LEFT_PAR;
                    constraint += it.next();
                } else {
                    constraint += SPACE + LogicalOperator.AND + SPACE + it.next();
                }
                if (!it.hasNext()) {
                    constraint += SPACE + RIGHT_PAR;
                }
            }
        }
        return constraint;
    }
}
