/**
 *   .       .     ..
 *  _| _  _.*|_  _ ||
 * (_](/,(_.|[_)(/,||
 *
 * DeciBell : A Java Tool for creating and managing relational databases.
 *  DeciBell is a Object - Relation database mapper for java applications providing
 * an easy-to-use interface making it easy for the developer to build a relational
 * database and moreover perform database operations easily!
 *  This project was developed at the Automatic Control Lab in the Chemical Engineering
 * School of the National Technical University of Athens. Please read README for more
 * information.
 *
 * Copyright (C) 2009-2010 Charalampos Chomenides & Pantelis Sopasakis
 *                         kinkyDesign ~ OpenSource Development

 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Contact:
 * hampos Att yahoo d0t c0m
 * chvng att mail D0t ntua dd0T gr
 * Address: Iroon Politechniou St. 9, Zografou, Athens Greece
 * tel. +30 210 7723236
 */
package org.kinkydesign.decibell.db.table;

import org.kinkydesign.decibell.db.interfaces.JTableColumn;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Set;
import org.kinkydesign.decibell.collections.LogicalOperator;
import org.kinkydesign.decibell.collections.OnModification;
import org.kinkydesign.decibell.collections.SQLType;
import org.kinkydesign.decibell.core.Component;
import org.kinkydesign.decibell.collections.Qualifier;

/**
 *
 * @author Pantelis Sopasakis
 * @author Charalampos Chomenides
 */
final public class TableColumn implements Cloneable, JTableColumn {

    private String columnName = "";
    private SQLType columnType = null;
    private boolean isPrimaryKey = false;
    private boolean isAutoGenerated = false;
    private String defaultValue = null;
    private boolean isNotNull = false;
    private boolean isUnique = false;
    private String[] domain;
    private String low;
    private String high;
    private boolean isConstrained = false;
    private boolean hasLow = false;
    private boolean hasHigh = false;
    private boolean hasDomain = false;
    private boolean hasDefault = false;
    private boolean isForeignKey = false;
    private String referencesTable = null;
    private String referencesColumn = null;
    private Class<? extends Component> referencesClass = null;
    private OnModification onUpdate = null;
    private OnModification onDelete = null;

    public TableColumn() {
        super();
    }

    public TableColumn(String columnName) {
        setColumnName(columnName);
    }

    public String getColumnName() {
        return this.columnName;
    }

    public void setColumnName(String columnName) {
        this.columnName = columnName;
    }

    public void setColumnType(SQLType columnType) {
        this.columnType = columnType;
    }

    public SQLType getColumnType() {
        return columnType;
    }

    public void setPrimaryKey(boolean isPrimaryKey, boolean isAutoGenerated) {
        this.isPrimaryKey = isPrimaryKey;
        this.isAutoGenerated = isAutoGenerated;
    }

    public boolean isPrimaryKey() {
        return isPrimaryKey;
    }

    public void setForeignKey(String TableName, String ForeignColumn, OnModification onDelete, OnModification onUpdate) {
        this.isForeignKey = true;
        this.referencesTable = TableName;
        this.referencesColumn = ForeignColumn;
        this.onDelete = onDelete;
        this.onUpdate = onUpdate;

    }

    public String getForeignKey() {
        String foreignKey = "";
        if (isForeignKey) {
            foreignKey = "FOREIGN KEY (" + columnName + ") REFERENCES " + referencesTable + "(" + referencesColumn + ")";
            foreignKey += " ON DELETE " + onDelete.toString();
            foreignKey += " ON UPDATE " + onUpdate.toString();
        }
        return foreignKey;
    }

    public String getReferenceTable() {
        return referencesTable;
    }

    public String getReferenceColumn() {
        return referencesColumn;
    }

    public OnModification getOnDelete() {
        return onDelete;
    }

    public OnModification getOnUpdate() {
        return onUpdate;
    }

    public void setDefaultValue(String defaultValue) {
        this.hasDefault = true;
        this.defaultValue = defaultValue;
    }

    public String getDefaultValue() {
        if (hasDefault) {
            return " DEFAULT " + this.defaultValue;
        } else {
            return "";
        }

    }

    public void setNotNull(boolean notNull) {
        this.isNotNull = notNull;
    }

    public boolean isNotNull() {
        return this.isNotNull;
    }

    public void setDomain(String[] domain) {
        this.isConstrained = true;
        this.hasDomain = true;
        this.domain = domain;
    }

    public void setLow(String low) {
        this.isConstrained = true;
        this.hasLow = true;
        this.low = low;
    }

    public void setHigh(String high) {
        this.isConstrained = true;
        this.hasHigh = true;
        this.high = high;
    }

    public String getConstraint() {
        String constraint = "";
        String lowStr = "";
        String highStr = "";
        String domainStr = "";
        Set<String> tempSet = new HashSet<String>();
        if (this.isConstrained) {            
            if (this.hasLow) {
                lowStr += columnName + Qualifier.GREATER_EQUAL + this.low;
                tempSet.add(lowStr);
            }
            if (this.hasHigh) {
                highStr += columnName + Qualifier.LESS_EQUAL + this.high;
                tempSet.add(highStr);
            }
            if (this.hasDomain) {
                for (int i = 0; i < this.domain.length; i++) {
                    if (!domain[i].isEmpty()) {
                        if (domainStr.isEmpty()) {
                            domainStr = columnName + " IN (";
                        } else {
                            domainStr += ", ";
                        }
                        if (this.columnType.equals(SQLType.VARCHAR) || this.columnType.equals(SQLType.LONG_VARCHAR)) {
                            domainStr += "'" + domain[i] + "'";
                        } else {
                            domainStr += domain[i];
                        }
                        if (i == domain.length - 1) {
                            domainStr += " )";
                        }
                    }
                }
                tempSet.add(domainStr);
            }
            Iterator<String> it = tempSet.iterator();
            while(it.hasNext()){
                if(constraint.isEmpty()){
                    constraint = " CONSTRAINT " + columnName + "_CONSTRAINT " + " CHECK ( ";
                    constraint += it.next();                    
                }else{
                    constraint += " " + LogicalOperator.AND + " " + it.next();
                }
                if(!it.hasNext()){
                    constraint += " )";
                }
            }
        }
        return constraint;
    }

    public void setUnique(boolean isUnique) {
        this.isUnique = isUnique;
    }

    public boolean isUnique() {
        return isUnique;
    }

    public boolean isForeignKey() {
        return isForeignKey;
    }

    public boolean isAutoGenerated() {
        return isAutoGenerated;
    }

    public boolean isConstrained() {
        return isConstrained;
    }

    public boolean hasLow(){
        return hasLow;
    }

    public boolean hasHigh(){
        return hasHigh;
    }

    public boolean hasDomain(){
        return hasDomain;
    }

    public String getHigh() {
        return high;
    }

    public String getLow() {
        return low;
    }

    public String[] getDomain() {
        return domain;
    }

    public boolean hasDefault() {
        return hasDefault;
    }

    public Class<? extends Component> getReferencesClass(){
        return referencesClass;
    }

    public void setReferencesClass(Class<? extends Component> referencesClass){
        this.referencesClass = referencesClass;
    }

    @Override
    public TableColumn clone(){
        try {
            return (TableColumn) super.clone();
        } catch (CloneNotSupportedException ex) {
            throw new RuntimeException(ex);
        }
    }


}
